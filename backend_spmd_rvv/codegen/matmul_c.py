"""
Task6 MVP: Emit a simple C/OpenMP matmul based on tile choices.

We deliberately generate readable scalar code (no RVV yet) to validate the
schedule mapping and allow compilation in environments without RVV.

Note: For the current end-to-end pipeline (IntentIR ops -> C -> remote RVV run),
use `backend_spmd_rvv.codegen.intentir_to_c.lower_intent_to_c_with_files`. This module remains
as a matmul-only prototype for tiling search experiments.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional

from intent_ir.ir_types import IntentFunction, IntentIRValidationError, Op
from ..analysis.tiling_search import TileChoice, SPMDProfile


@dataclass
class MatmulSignature:
    a: str
    b: str
    c: str
    m: str
    n: str
    k: str


def _find_first_matmul(intent: IntentFunction) -> Op:
    for op in intent.ops:
        if op.op == "matmul":
            return op
    raise IntentIRValidationError("matmul_c currently supports only matmul intents")


def _infer_sig(intent: IntentFunction, op: Op) -> MatmulSignature:
    # Use tensor names as parameter names; fall back to A/B/C if missing.
    a = op.inputs[0] if op.inputs else "A"
    b = op.inputs[1] if len(op.inputs) > 1 else "B"
    c = op.output or "C"

    def _dim_name(tensor_name: str, idx: int, fallback: str) -> str:
        t = intent.tensors.get(tensor_name)
        if t and len(t.shape) > idx:
            d = t.shape[idx]
            if hasattr(d, "value") and isinstance(d.value, str):
                return d.value
        return fallback

    m = _dim_name(a, 0, "M")
    k = _dim_name(a, 1, "K")
    n = _dim_name(b, 1, "N")
    return MatmulSignature(a=a, b=b, c=c, m=str(m), n=str(n), k=str(k))


def generate_c(intent: IntentFunction, tile: TileChoice, profile: SPMDProfile, *, func_name: Optional[str] = None) -> str:
    """
    Generate a C/OpenMP matmul using the given tile sizes.
    """
    op = _find_first_matmul(intent)
    sig = _infer_sig(intent, op)
    fn = func_name or f"matmul_{intent.name}"

    pragma_parallel = ""
    par_axes = intent.schedule.parallel_axes if intent.schedule and intent.schedule.parallel_axes else intent.parallel_axes
    if len(par_axes) >= 2:
        pragma_parallel = "#pragma omp parallel for collapse(2)\n"
    elif len(par_axes) == 1:
        pragma_parallel = "#pragma omp parallel for\n"

    tm = tile.tile_m
    tn = tile.tile_n
    tk = tile.tile_k

    lines = []
    lines.append("#include <stddef.h>")
    lines.append("#ifdef _OPENMP\n#include <omp.h>\n#endif")
    lines.append("")
    lines.append("/* Auto-generated by backend_spmd_rvv.codegen.matmul_c (Task6 MVP) */")
    lines.append(f"void {fn}(const float* {sig.a}, const float* {sig.b}, float* {sig.c}, int {sig.m}, int {sig.n}, int {sig.k}) {{")
    lines.append(f"  const int TM = {tm};")
    lines.append(f"  const int TN = {tn};")
    lines.append(f"  const int TK = {tk};")
    lines.append(f"  // profile: num_cores={profile.num_cores}, rvv_enabled={profile.rvv_enabled}")
    if tile.vec_width:
        lines.append(f"  // vec_width hint: {tile.vec_width}")
    if tile.notes:
        for n in tile.notes:
            lines.append(f"  // note: {n}")
    lines.append(f"{pragma_parallel}  for (int m0 = 0; m0 < {sig.m}; m0 += TM) {{")
    lines.append(f"    for (int n0 = 0; n0 < {sig.n}; n0 += TN) {{")
    lines.append(f"      for (int k0 = 0; k0 < {sig.k}; k0 += TK) {{")
    lines.append("        int m_max = m0 + TM; if (m_max > {M}) m_max = {M};".format(M=sig.m))
    lines.append("        int n_max = n0 + TN; if (n_max > {N}) n_max = {N};".format(N=sig.n))
    lines.append("        int k_max = k0 + TK; if (k_max > {K}) k_max = {K};".format(K=sig.k))
    lines.append("        for (int m = m0; m < m_max; ++m) {")
    lines.append("          for (int n = n0; n < n_max; ++n) {")
    lines.append("            float acc = 0.0f;")
    lines.append("            for (int k = k0; k < k_max; ++k) {")
    lines.append(f"              acc += {sig.a}[m * {sig.k} + k] * {sig.b}[k * {sig.n} + n];")
    lines.append("            }")
    lines.append(f"            {sig.c}[m * {sig.n} + n] += acc;")
    lines.append("          }")
    lines.append("        }")
    lines.append("      }")
    lines.append("    }")
    lines.append("  }")
    lines.append("}")
    return "\n".join(lines)


__all__ = ["generate_c"]
